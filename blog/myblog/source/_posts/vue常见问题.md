---

title: vue常见问题 --- 1
date: 2020-04-22 15:50:17
Tags: Vue

---



#### `v-if`  和  `v-for` 的优先级哪个最高 

` v-if`  和 `v-for`的优先级哪个最高，如果两个同时出现，应该怎么优化得到更好的性能。

1. `v-for` 优先于 `v-if ` 被解析，`v-for`  比 ` v-if` 具有更高的优先级。
2. 如果同时出现，每次循环都会先执行循环再执行判断条件，无论如何循环都不可避免，浪费性能。
3. 要避免同时出现，在外层嵌套 `template`， 先进行 `v-if` 。

#### vue组件的data必须是个函数而根组件没有这个限制

为了保证多实例的时候状态不会互相干扰，而根组件只会创建一次，单例。

vue的组件可能存在多个实例，如果使用对象形式定义data，则会导致他们共用一个data对象，那么状态变更将会影响所有组件实例，这是不合理的，如果使用函数形式定义，在initdata的时候会将其作为工厂函数返回全新的data对象，有效规避多实例之间状态污染的问题。而根实例创建过程中则不存在该限制，也是因为根实例只能有一个，不需要担心这种情况。之前看源码的时候，数据初始化的时候会检测数据的格式，从而决定数据处理的方式。根实例是能拿到实例的所以能够躲过校验，而其他的数据合并的时候并没有实例生成，所以会直接被检测出来。

#### `key` 的作用和原理

1. `key` 的作用是可以高效的更新虚拟 `dom`，其原理是 `vue` 在 `patch` 过程中可以通过 `key` 来精准的判断两个节点是否是同一个，从而避免更新不同的元素，使得整个过程更高效，减少 `dom` 操作，提高性能。

2. 另外，不设置 `key` 可能在列表更新时隐藏的`bug`。

3. `vue` 在使用相同标签名元素的过渡切换时，也会使用到`key` 属性，目的也是为了可以更好的区分它们，否则vue只会更新内部属性，而忽略过渡效果。

 #### 如何理解 `vue` 的 `diff` 算法

1. 必要性 `lifecycle.js` 中的 `mountComponentn()`

   这个方法是由 `$mount` 调用的，一个组件调用一次就会创建一次 `Wathcer`，组件中可能存在很多个 `data`的`key` 使用，但是 `Watcher` 只有一个，要确保多个 `key` 都能更新，要精确的知道某个` key ` 进行变动，必须要使用diff。

2. 执行 `patch.js`  ` patchVnode()`

   `patchVnode` 是 `diff` 发生的地方，整体的策略为：深度优先 同层比较。

   先比较根节点，判断是否有子节点；如果都有孩子，则更新孩子（递归操作），然后同级比较。

3. 高效性 `patch.js`  `updateChildren`

- `Diff`  算法是虚拟`dom` 技术的必然产物：通过新旧虚拟`dom` 做对比，将变化的地方更新在真实的`dom` 上，另外，也需要 `diff` 高效的执行对比过程，从而降低时间复杂度`O(n)`。
- `vue` 2.x 为了降低 `Watcher` 粒度，每个组件只有一个 `Watcher`  与之对应，只有引入 `diff` 才能精确找到发生变化的地方。
- `vue` 中的`diff` 执行的时刻是组件实例执行其更新函数时。
  - 我们修改一个数据时，由于数据响应式，出发了`setter` ，出发了通知。
  - 通知尝试将`Watcher`添加异步更新队列，每次事件循环结束会清空异步队列，所有的`Watcher`尝试执行更新函数。
  - 更新函数调用了组件的更新函数和渲染函数，重新渲染虚拟 `dom`，它会比对上一次渲染结果 `oldVnode`和新的渲染结果 `newVnode`，此过程称为 `patch` 。
- `diff` 过程整体遵循深度优先，同层比较的策略；两个节点之间比较会根据他们是否拥有子节点或者文本节点做不同操作，比较两组子节点是算法的重点，首先假设头尾节点可能相同做4次比对尝试，如果没有找到相同节点才按照通用方式遍历查找，查找结束再按情况处理剩下的节点；借助 `key` 通常可以非常精确找到相同节点，因此整个`patch`过程非常高效。

#### `vue` 组件化的理解

1. 组件是独立和可复用的代码组织单元。组件系统是Vue的核心特性之一，它使开发者使用小型、独立和通常可复用的组件构建大型应用
2. 组件化开发能大幅提高应用开发效率、测试性、复用性等
3. 组件使用按分类有：页面组件、业务组件、通用组件
4. vue的组件是基于配置的，我们通常编写的组件是组件配置而非组件，框架后续回升长期构造函数，他们基于vueComponent，扩展与Vue。
5. vue中常见组件化技术有：属性props、自定义事件、插槽等，他们主要用于组件通信、扩展
6. 合理的划分组件，有助于提升应用性能，一个组件对应一个watcher，合理的颗粒化降低渲染时的复杂度
7. 组件应该是高内聚、低耦合
8. 遵循单项数据流原则