---
title: 学习笔记二
date: 2020-04-24 13:59:48
tags: web

---

- 洋葱模型

  中间件模式

  reduce 函数是函数式编程的一个重要概念，可用于实现函数组合（compose）

  参考

  <a href="http://tangqq.cn/web/shen-ru-li-jie-yang-cong-mo-xing-zhong-jian-jian-ji-zhi">深入了解洋葱模型</a>

- 多个项目维护打包区分模块

  目前看来很多公司都是使用公用模块单独打包成`npm`即可（可私有或者公有），A和B依赖这个公用模块即可

- 环境变量的设定

  1. 使用 `cross-env` 设置

     缺点是 

     1.1 ` scripts` 命令过长，书写过程不方便

     1.2 变量混杂

     1.3 多环境变量引入，需要添加额外的命令

  2. 直接使用不同的命令，使用命令来区分，然后引入不同的json

     比如 `env-cmd`

     

- apollo

  Apollo（阿波罗）是携程框架部门研发的开源配置管理中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性。

  <a href="[https://github.com/ctripcorp/apollo/wiki/Go%E3%80%81Python%E3%80%81NodeJS%E3%80%81PHP%E7%AD%89%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97](https://github.com/ctripcorp/apollo/wiki/Go、Python、NodeJS、PHP等客户端使用指南)" >Go、Python、NodeJS、PHP等客户端使用指南</a>

- 微前端

  <a href="https://baijiahao.baidu.com/s?id=1638313846156942854&wfr=spider&for=pc">微前端</a>

  为什么要使用微前端

  - 遗留系统迁移
  - 聚合前端应用
  - 热闹驱动开发

  微前端能带来的好处

  - 应用自治
  - 单一指责
  - 无关技术栈

  如何设计微前端架构

  >  架构模式

  1. 基座模式

     通过一个主应用，来管理其他应用，设计难度小，方便实践，但是通用度低。

  2. 自组织式

     应用之间是平等，不存在相互管理的模式。设计难度大，不方便实施，但是通用度高。

  > 服务的注册表模式

  1. 应用发现

     让主应用可以寻找到其他应用

  2. 应用注册

     提供新的微前端应用，向应用注册表注册的功能

  3. 第三方应用注册

     让第三方的应用，可以介入到系统中

  4. 访问权限等配置

  > 设计理念

  - 中心化 

    应用注册表，拥有每个应用及对应的入口。在前端领域里，入口的直接表现形式可以是路由，又或者对应的应用映射。

  - 标识化应用

    我们需要一个标识符来标识不同的应用，以便于在安装、卸载的时候，能寻找到执行的应用。

  - 应用生命周期管理

  - 高内聚低耦合

  > 生命周期

  - Load 决定加载哪个应用
  - Bootstrap 获取静态资源
  - Mount 安装使用，如创建DOM节点、取消事件绑定
  - Unload 删除应用的生命周期
  - Unmount 卸载应用，如删除DOM节点

  > 技术方式

  - 路由分发式
    - 通过路由将不同的业务分发到不同的、独立前端应用上，通常通过 `HTTP` 服务器的反向代理实现。
  - 前端微服务化
    - 每个前端应用都是完全独立（技术栈、开发、部署、构建独立）、独立运行，最后通过模块化的方式组合出完整的前端应用。

  - 微应用

    开发时，应用都是以单一、微小应用的形式存在，运行时通过构建系统合并这些应用。以软件工程的方式，来完成前端应用的开发，因此又可以称之为组合式集成。

  - 微件化

  - 前端容器化

  - 应用组件化

  > 业务拆分

  - 按照业务拆分
  - 按照权限拆分
  - 按照变更的频率拆分
  - 按照组织结构拆分
  - 跟随后端微服务拆分

- monorepo 设计思路

  Monorepo 简单的说，是指将公司的所有代码放到一个 Git / Mercurial / Subversion 的代码仓库中。

  monorepo 最主要的好处是**统一的工作流**和**Code Sharing**。

  一个理想的开发环境可以抽象成这样：

  “只关心业务代码，可以直接跨业务复用而不关心复用方式，调试时所有代码都在源码中。”

  理想 `monorepo` 的设计

  全局配置文件只有一个，`node_modules` 也只有一个，既保证了项目依赖的一致性，又避免了依赖被重复安装，节省空间的同时还提高了安装速度。

  兄弟模块之间通过模块 `pakeage.json` 定义的 `name` 相互饮用，保证模块之间的独立性，但又不需要真正发布或安装这个模块，通过 `tsconfig.json` 的 `paths` 与 `webpack` 的 `alias` 共同实现虚拟模块路径的效果。

  常用的monorepo工具  <a href="https://github.com/lerna/lerna">learna</a>

- cicd 

  CI / CD的采用改变了开发人员和测试人员如何发布软件。

  CI  (Continuous Integration) 持续集成

  CD(Continuous Delivery) 持续交付

  CD(Continuous Deployment) 持续部署

- docker

  - Web 应用的自动化打包和发布。
  - 自动化测试和持续集成、发布。
  - 在服务型环境中部署和调整数据库或其他的后台应用。

- nginx

  Nginx("engine x")是一款是由俄罗斯的程序设计师Igor Sysoev所开发高性能的 Web和 反向代理 服务器，也是一个 IMAP/POP3/SMTP 代理服务器。

  在高连接并发的情况下，Nginx是Apache服务器不错的替代品。

- RWD

  响应式网站设计(简称RWD)是一种新的网站设计模式，以此构建的网站可自动适应不同的访问设备(从桌面电脑、平板电脑到智能手机)，方便用户阅读和导航浏览，减少用户的放大/缩小/滑动操作，从而提供完整而友好的用户体验。

- 手写promise

  ```
  function Promise(executor) {
    var _this = this;
    this.state = "pending";
    this.value = undefined;
    this.reason = undefined;
    this.onFullfilledFunc = [];
    this.onRejectedFunc = [];
    executor(resolve, reject);
  
    function resolve(value) {
      if (_this.state === "pending") {
        _this.value = value;
        _this.onFullfilledFunc.forEach(fn => {
          fn(value);
        });
        _this.state = "resoled";
      }
    }
    function reject(reason) {
      if (_this.state === "pending") {
        _this.reason = reason;
        _this.onRejectedFunc.forEach(fn => {
          fn(reason);
        });
        _this.state = "rejected";
      }
    }
  }
  
  Promise.prototype.then = function(onFullfilled, onRejected) {
    if (this.state === "resolved") {
      if (typeof onFullfilled === "function") {
        onFullfilled(this.value);
      }
    }
    if (this.state === "rejected") {
      if (typeof onRejected === "function") {
        onRejected(this.reason);
      }
    }
    if (this.state === "pending") {
      if (typeof onFullfilled === "function") {
        this.onFullfilledFunc.push(onFullfilled);
      }
      if (typeof onRejected === "function") {
        this.onRejectedFunc.push(onRejected);
      }
    }
  };
  
  
  let p = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(1);
    },500);
  });
  
  p.then(data => console.log(data)); //没有任何结果
  ```

  

- 从零搭建一个项目，你会怎么去做，比如文件怎么划分模块，业务啊功能模块的区分，webpack打包环境控制，config文件定义之类

  

- 项目怎么部署发布的

- serverless

