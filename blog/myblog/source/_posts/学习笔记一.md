---
title: 学习笔记-
date: 2020-04-24 13:55:13
tags: web
---

- 如何看待高阶函数

  javaScript 中的一切都是对象，包括函数。我们可以将变量作为参数传递给函数，函数也是如此。高阶函数就是一个将函数作为参数或者返回值的函数。

- web安全前端能做什么

  去查询被劫持的js，看操作的是什么dom，然后销毁他使用的dom，或者占用他使用的id。

- 闭包

  **闭包函数：**声明在一个函数中的函数，叫做闭包函数。

  **闭包：**内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。

- 装饰器

  他通过添加`@方法名`可以对一些对象进行装饰包装然后返回一个被包装过的对象，可以装饰的对象包括：类，属性，方法等

  1. 类的装饰

     当装饰的对象是类时，我们操作的就是这个类的本身，即装饰器函数的第一个参数，就是所要装饰的目标类。

  2. 属性或方法的装饰

     对于类属性或方法的装饰本质是操作起描述符，可以把此事的装饰器理解成 `object.defineProperty(obj,props,descriptor)` 的语法糖。

- flex布局常用的属性

  弹性布局

  - flex-direction

    ```css
    row（默认值）：主轴为水平方向，起点在左端。
    row-reverse：主轴为水平方向，起点在右端。
    column：主轴为垂直方向，起点在上沿。
    column-reverse：主轴为垂直方向，起点在下沿。
    ```

  - flex-wrap

    `nowrap`（默认）：不换行。

    `wrap`：换行，第一行在上方。

    `wrap-reverse`：换行，第一行在下方。

  - flex-flow

    `flex-flow`属性是`flex-direction`属性和`flex-wrap`属性的简写形式，默认值为`row nowrap`。

  - justify-content

    - `flex-start`（默认值）：左对齐
    - `flex-end`：右对齐
    - `center`： 居中
    - `space-between`：两端对齐，项目之间的间隔都相等。
    - `space-around`：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。

  - align-items

    - `flex-start`：交叉轴的起点对齐。
    - `flex-end`：交叉轴的终点对齐。
    - `center`：交叉轴的中点对齐。
    - `baseline`: 项目的第一行文字的基线对齐。
    - `stretch`（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。

  - align-content

    - `flex-start`：与交叉轴的起点对齐。
    - `flex-end`：与交叉轴的终点对齐。
    - `center`：与交叉轴的中点对齐。
    - `space-between`：与交叉轴两端对齐，轴线之间的间隔平均分布。
    - `space-around`：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
    - `stretch`（默认值）：轴线占满整个交叉轴。

- div的垂直水平居中

  1. margin auto

  ```
  css:
  div{
  width: 400px;
  height: 400px;
  position: relative;
  border: 1px solid #465468;
  }
  img{
  position: absolute;
  margin: auto;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  }
  html:
  <div>
  <img src="mm.jpg">
  </div>
  ```

  2. margin负值法

     ```
     .container{
     width: 500px;
     height: 400px;
     border: 2px solid #379;
     position: relative;
     }
     .inner{
     width: 480px;
     height: 380px;
     background-color: #746;
     position: absolute;
     top: 50%;
     left: 50%;
     ```

  3. table-cell（未脱离文档流的）

     ``

     ```
     div{
     width: 300px;
     height: 300px;
     border: 3px solid #555;
     display: table-cell;
     vertical-align: middle;
     text-align: center;
     }
     img{
     vertical-align: middle;
     }
     ```

  4. 利用flex

     ``

     ```
     css:
     .container{
     width: 300px;
     height: 200px;
     border: 3px solid #546461;
     display: -webkit-flex;
     display: flex;
     -webkit-align-items: center;
     align-items: center;
     -webkit-justify-content: center;
     justify-content: center;
     }
     .inner{
     border: 3px solid #458761;
     padding: 20px;
     }
     ```

- import 和 require的区别（编译阶段）

  common js

  导出

  ```
  // testcommonjs.js
  exports.a = 123;
  exports.c = function(){
    console.log('ccc')
  }
  exports.d = {
    foo: 'bar'
  }
  
  //等价=> 
  module.exports.a = 123;
  
  
  //等价=> 
  module.exports = {
    a:123,
    b:'hello',
    c:function(){
      console.log('ccc')
    },
    d:{
      foo：bar
    }
  }
  //index
  
  var test = require('./testcommonjs')
  console.log(test.a)
  console.log(test.b)
  test.c()
  console.log(test.d.foo)
  ```

  es6

  ```
  import { a,b,c,d } from './testesmodule'
  
  console.log(a)
  console.log(b)
  c()
  console.log(d.foo)
  
  //等价=> 
  import * as test form './testesmodule'
  console.log(test.a)
  console.log(test.b)
  test.c()
  
  ```

  本质上的区别

  1. CommonJS 还是 ES6 Module 输出都可以看成是一个具备多个属性或者方法的对象；

  2. default 是 ES6 Module 所独有的关键字，export default fs 输出默认的接口对象，import fs from 'fs' 可直接导入这个对象；

  3. ES6 Module 中导入模块的属性或者方法是强绑定的，包括基础类型；而 CommonJS 则是普通的值传递或者引用传递。

  4. import和require区别

     node编程中最重要的思想是模块化，import和require都是被模块化使用

     require是运行时调用，所以可以随处引入

     import是编译时调用，必须放在文件开头引入，目前部分浏览器不支持，需要用babel把es6转成es5再执行

- 技术选型更看重什么

- react生命周期

  挂载

  - constructor

  - static getDerivedStateFromProps()

  - render

  - componentDidMount

  更新

  - static getDerivedStateFromProps
  - shouldComponenntUpdate
  - render
  - getSnapshotBeforeUpdate
  - componentDidUpdate

  卸载

  - componentWillUnmount

  错误处理

  - static getDerivedStateFromError
  - componentDidCatch



